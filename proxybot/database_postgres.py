from __future__ import annotations

import secrets
from typing import Any
from urllib.parse import quote

import psycopg
from psycopg.rows import dict_row

from .database import DEFAULT_PLANS, Plan, ProxyPoolEntry, now_ts


class PostgresDatabase:
    def __init__(self, dsn: str):
        self.dsn = dsn
        self._conn: psycopg.AsyncConnection | None = None

    @property
    def conn(self) -> psycopg.AsyncConnection:
        if self._conn is None:
            raise RuntimeError("Database is not connected.")
        return self._conn

    async def connect(self) -> None:
        self._conn = await psycopg.AsyncConnection.connect(self.dsn, row_factory=dict_row)
        await self._conn.set_autocommit(True)

    async def close(self) -> None:
        if self._conn is not None:
            await self._conn.close()
            self._conn = None

    async def init_schema(self) -> None:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                CREATE TABLE IF NOT EXISTS users (
                    id BIGSERIAL PRIMARY KEY,
                    tg_user_id BIGINT NOT NULL UNIQUE,
                    username TEXT,
                    first_name TEXT,
                    last_name TEXT,
                    created_at BIGINT NOT NULL,
                    updated_at BIGINT NOT NULL
                );

                CREATE TABLE IF NOT EXISTS plans (
                    code TEXT PRIMARY KEY,
                    title TEXT NOT NULL,
                    devices_count INTEGER NOT NULL,
                    price_rub INTEGER NOT NULL,
                    duration_days INTEGER NOT NULL
                );

                CREATE TABLE IF NOT EXISTS payments (
                    id BIGSERIAL PRIMARY KEY,
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    plan_code TEXT NOT NULL REFERENCES plans(code),
                    amount_rub INTEGER NOT NULL,
                    status TEXT NOT NULL CHECK(status IN ('pending', 'paid', 'cancelled')),
                    created_at BIGINT NOT NULL,
                    paid_at BIGINT
                );

                CREATE TABLE IF NOT EXISTS subscriptions (
                    id BIGSERIAL PRIMARY KEY,
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    plan_code TEXT NOT NULL REFERENCES plans(code),
                    payment_id BIGINT NOT NULL UNIQUE REFERENCES payments(id),
                    status TEXT NOT NULL CHECK(status IN ('active', 'expired')),
                    created_at BIGINT NOT NULL,
                    expires_at BIGINT NOT NULL,
                    notified_expired INTEGER NOT NULL DEFAULT 0
                );

                CREATE TABLE IF NOT EXISTS proxy_links (
                    id BIGSERIAL PRIMARY KEY,
                    subscription_id BIGINT NOT NULL REFERENCES subscriptions(id),
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    device_number INTEGER NOT NULL,
                    token TEXT NOT NULL UNIQUE,
                    link TEXT NOT NULL,
                    status TEXT NOT NULL CHECK(status IN ('active', 'expired')),
                    created_at BIGINT NOT NULL,
                    expires_at BIGINT NOT NULL
                );

                CREATE TABLE IF NOT EXISTS proxy_pool (
                    id BIGSERIAL PRIMARY KEY,
                    port INTEGER NOT NULL UNIQUE,
                    username TEXT NOT NULL,
                    password TEXT NOT NULL,
                    status TEXT NOT NULL CHECK(status IN ('free', 'assigned')),
                    assigned_link_id BIGINT UNIQUE REFERENCES proxy_links(id),
                    created_at BIGINT NOT NULL,
                    updated_at BIGINT NOT NULL
                );

                CREATE TABLE IF NOT EXISTS proxy_delivery_logs (
                    id BIGSERIAL PRIMARY KEY,
                    proxy_link_id BIGINT NOT NULL REFERENCES proxy_links(id),
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    tg_user_id BIGINT NOT NULL,
                    user_label TEXT NOT NULL,
                    subscription_id BIGINT REFERENCES subscriptions(id),
                    device_number INTEGER,
                    delivery_source TEXT NOT NULL CHECK(delivery_source IN ('purchase', 'my_links')),
                    proxy_url TEXT NOT NULL,
                    delivered_at BIGINT NOT NULL
                );

                CREATE TABLE IF NOT EXISTS user_temp_messages (
                    id BIGSERIAL PRIMARY KEY,
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    tg_user_id BIGINT NOT NULL,
                    message_id BIGINT NOT NULL,
                    kind TEXT NOT NULL,
                    created_at BIGINT NOT NULL,
                    UNIQUE(user_id, message_id, kind)
                );

                CREATE TABLE IF NOT EXISTS banned_users (
                    id BIGSERIAL PRIMARY KEY,
                    tg_user_id BIGINT NOT NULL UNIQUE,
                    reason TEXT NOT NULL,
                    blocked_by BIGINT,
                    blocked_at BIGINT NOT NULL
                );

                CREATE INDEX IF NOT EXISTS idx_users_tg_user_id ON users(tg_user_id);
                CREATE INDEX IF NOT EXISTS idx_payments_user_status ON payments(user_id, status);
                CREATE INDEX IF NOT EXISTS idx_subscriptions_user_status ON subscriptions(user_id, status);
                CREATE INDEX IF NOT EXISTS idx_subscriptions_expires_at ON subscriptions(expires_at);
                CREATE INDEX IF NOT EXISTS idx_proxy_links_user_status ON proxy_links(user_id, status);
                CREATE INDEX IF NOT EXISTS idx_proxy_links_expires_at ON proxy_links(expires_at);
                CREATE INDEX IF NOT EXISTS idx_proxy_pool_status ON proxy_pool(status);
                CREATE INDEX IF NOT EXISTS idx_proxy_delivery_logs_tg_user_id ON proxy_delivery_logs(tg_user_id);
                CREATE INDEX IF NOT EXISTS idx_proxy_delivery_logs_proxy_link_id ON proxy_delivery_logs(proxy_link_id);
                CREATE INDEX IF NOT EXISTS idx_user_temp_messages_user_kind ON user_temp_messages(user_id, kind);
                CREATE INDEX IF NOT EXISTS idx_banned_users_tg_user_id ON banned_users(tg_user_id);
                """
            )
        await self.seed_plans()
        await self.conn.commit()

    async def seed_plans(self) -> None:
        async with self.conn.cursor() as cur:
            for plan in DEFAULT_PLANS:
                await cur.execute(
                    """
                    INSERT INTO plans (code, title, devices_count, price_rub, duration_days)
                    VALUES (%s, %s, %s, %s, %s)
                    ON CONFLICT(code) DO UPDATE SET
                        title = EXCLUDED.title,
                        devices_count = EXCLUDED.devices_count,
                        price_rub = EXCLUDED.price_rub,
                        duration_days = EXCLUDED.duration_days
                    """,
                    (plan.code, plan.title, plan.devices_count, plan.price_rub, plan.duration_days),
                )
        await self.conn.commit()

    async def sync_proxy_pool(self, entries: list[ProxyPoolEntry]) -> None:
        timestamp = now_ts()
        async with self.conn.cursor() as cur:
            for item in entries:
                await cur.execute(
                    """
                    INSERT INTO proxy_pool (port, username, password, status, created_at, updated_at)
                    VALUES (%s, %s, %s, 'free', %s, %s)
                    ON CONFLICT(port) DO UPDATE SET
                        username = EXCLUDED.username,
                        password = EXCLUDED.password,
                        updated_at = EXCLUDED.updated_at
                    """,
                    (item.port, item.username, item.password, timestamp, timestamp),
                )

            ports = [item.port for item in entries]
            if ports:
                await cur.execute(
                    """
                    DELETE FROM proxy_pool
                    WHERE status = 'free' AND NOT (port = ANY(%s))
                    """,
                    (ports,),
                )
            else:
                await cur.execute(
                    """
                    DELETE FROM proxy_pool
                    WHERE status = 'free'
                    """
                )
        await self.conn.commit()

    async def upsert_user(
        self,
        tg_user_id: int,
        username: str | None,
        first_name: str | None,
        last_name: str | None,
    ) -> int:
        timestamp = now_ts()
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                INSERT INTO users (tg_user_id, username, first_name, last_name, created_at, updated_at)
                VALUES (%s, %s, %s, %s, %s, %s)
                ON CONFLICT(tg_user_id) DO UPDATE SET
                    username = EXCLUDED.username,
                    first_name = EXCLUDED.first_name,
                    last_name = EXCLUDED.last_name,
                    updated_at = EXCLUDED.updated_at
                RETURNING id
                """,
                (tg_user_id, username, first_name, last_name, timestamp, timestamp),
            )
            row = await cur.fetchone()
        await self.conn.commit()
        if row is None:
            raise RuntimeError("Failed to upsert user.")
        return int(row["id"])

    async def get_user_by_tg_user_id(self, tg_user_id: int) -> dict[str, Any] | None:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                SELECT id, tg_user_id, username, first_name, last_name, created_at, updated_at
                FROM users
                WHERE tg_user_id = %s
                """,
                (tg_user_id,),
            )
            row = await cur.fetchone()
        return dict(row) if row is not None else None

    async def get_all_tg_user_ids(self) -> list[int]:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                SELECT tg_user_id
                FROM users
                ORDER BY id ASC
                """
            )
            rows = await cur.fetchall()
        return [int(row["tg_user_id"]) for row in rows]

    async def list_users_with_stats(self, limit: int = 200, offset: int = 0) -> list[dict[str, Any]]:
        timestamp = now_ts()
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                SELECT
                    u.id,
                    u.tg_user_id,
                    u.username,
                    u.first_name,
                    u.last_name,
                    u.created_at,
                    u.updated_at,
                    SUM(CASE WHEN pl.status = 'active' AND pl.expires_at > %s THEN 1 ELSE 0 END) AS active_proxies,
                    CASE WHEN bu.tg_user_id IS NULL THEN 0 ELSE 1 END AS is_banned
                FROM users u
                LEFT JOIN proxy_links pl ON pl.user_id = u.id
                LEFT JOIN banned_users bu ON bu.tg_user_id = u.tg_user_id
                GROUP BY u.id, bu.tg_user_id
                ORDER BY u.created_at DESC
                LIMIT %s OFFSET %s
                """,
                (timestamp, max(1, limit), max(0, offset)),
            )
            rows = await cur.fetchall()
        return [dict(row) for row in rows]

    async def get_plan(self, code: str) -> Plan | None:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                SELECT code, title, devices_count, price_rub, duration_days
                FROM plans
                WHERE code = %s
                """,
                (code,),
            )
            row = await cur.fetchone()
        if row is None:
            return None
        return Plan(
            code=row["code"],
            title=row["title"],
            devices_count=int(row["devices_count"]),
            price_rub=int(row["price_rub"]),
            duration_days=int(row["duration_days"]),
        )

    async def get_plans(self) -> list[Plan]:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                SELECT code, title, devices_count, price_rub, duration_days
                FROM plans
                ORDER BY devices_count ASC
                """
            )
            rows = await cur.fetchall()
        return [
            Plan(
                code=row["code"],
                title=row["title"],
                devices_count=int(row["devices_count"]),
                price_rub=int(row["price_rub"]),
                duration_days=int(row["duration_days"]),
            )
            for row in rows
        ]

    async def create_payment(self, user_id: int, plan_code: str, amount_rub: int) -> int:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                INSERT INTO payments (user_id, plan_code, amount_rub, status, created_at)
                VALUES (%s, %s, %s, 'pending', %s)
                RETURNING id
                """,
                (user_id, plan_code, amount_rub, now_ts()),
            )
            row = await cur.fetchone()
        await self.conn.commit()
        if row is None:
            raise RuntimeError("Failed to create payment.")
        return int(row["id"])

    async def get_payment_for_user(self, payment_id: int, user_id: int) -> dict[str, Any] | None:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                SELECT id, user_id, plan_code, amount_rub, status, created_at, paid_at
                FROM payments
                WHERE id = %s AND user_id = %s
                """,
                (payment_id, user_id),
            )
            row = await cur.fetchone()
        return dict(row) if row is not None else None

    async def cancel_pending_payment(self, payment_id: int, user_id: int) -> bool:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                UPDATE payments
                SET status = 'cancelled'
                WHERE id = %s AND user_id = %s AND status = 'pending'
                """,
                (payment_id, user_id),
            )
            changed = cur.rowcount > 0
        await self.conn.commit()
        return changed

    async def count_free_pool(self) -> int:
        async with self.conn.cursor() as cur:
            await cur.execute(
                "SELECT COUNT(*) AS cnt FROM proxy_pool WHERE status = 'free'"
            )
            row = await cur.fetchone()
        return int(row["cnt"]) if row is not None else 0

    async def activate_payment_and_create_subscription_from_pool(
        self,
        *,
        payment_id: int,
        user_id: int,
        plan_code: str,
        expires_at: int,
        devices_count: int,
        proxy_public_host: str,
    ) -> tuple[int, list[dict[str, Any]]] | None:
        timestamp = now_ts()
        await self.conn.execute("BEGIN")
        try:
            async with self.conn.cursor() as cur:
                await cur.execute(
                    """
                    UPDATE payments
                    SET status = 'paid', paid_at = %s
                    WHERE id = %s AND user_id = %s AND status = 'pending'
                    """,
                    (timestamp, payment_id, user_id),
                )
                if cur.rowcount == 0:
                    await self.conn.rollback()
                    return None

                await cur.execute(
                    """
                    SELECT id, port, username, password
                    FROM proxy_pool
                    WHERE status = 'free'
                    ORDER BY port ASC
                    LIMIT %s
                    FOR UPDATE SKIP LOCKED
                    """,
                    (devices_count,),
                )
                proxy_rows = await cur.fetchall()
                if len(proxy_rows) < devices_count:
                    await self.conn.rollback()
                    return None

                await cur.execute(
                    """
                    INSERT INTO subscriptions (user_id, plan_code, payment_id, status, created_at, expires_at)
                    VALUES (%s, %s, %s, 'active', %s, %s)
                    RETURNING id
                    """,
                    (user_id, plan_code, payment_id, timestamp, expires_at),
                )
                sub_row = await cur.fetchone()
                if sub_row is None:
                    raise RuntimeError("Failed to create subscription.")
                subscription_id = int(sub_row["id"])

                created: list[dict[str, Any]] = []
                for device_number, proxy_row in enumerate(proxy_rows, start=1):
                    port = int(proxy_row["port"])
                    username = str(proxy_row["username"])
                    password = str(proxy_row["password"])

                    username_safe = quote(username, safe="")
                    password_safe = quote(password, safe="")
                    link = f"socks5://{username_safe}:{password_safe}@{proxy_public_host}:{port}"

                    await cur.execute(
                        """
                        INSERT INTO proxy_links (
                            subscription_id, user_id, device_number, token, link, status, created_at, expires_at
                        )
                        VALUES (%s, %s, %s, %s, %s, 'active', %s, %s)
                        RETURNING id
                        """,
                        (
                            subscription_id,
                            user_id,
                            device_number,
                            secrets.token_urlsafe(18),
                            link,
                            timestamp,
                            expires_at,
                        ),
                    )
                    link_row = await cur.fetchone()
                    if link_row is None:
                        raise RuntimeError("Failed to create proxy link.")
                    link_id = int(link_row["id"])

                    await cur.execute(
                        """
                        UPDATE proxy_pool
                        SET status = 'assigned', assigned_link_id = %s, updated_at = %s
                        WHERE id = %s AND status = 'free'
                        """,
                        (link_id, timestamp, int(proxy_row["id"])),
                    )
                    if cur.rowcount == 0:
                        raise RuntimeError("Failed to assign proxy from pool")

                    created.append(
                        {
                            "proxy_id": link_id,
                            "device_number": device_number,
                            "port": port,
                            "username": username,
                            "password": password,
                            "link": link,
                        }
                    )

            await self.conn.commit()
            return subscription_id, created
        except Exception:
            await self.conn.rollback()
            raise

    async def log_proxy_delivery(
        self,
        *,
        proxy_link_id: int,
        user_id: int,
        tg_user_id: int,
        user_label: str,
        subscription_id: int | None,
        device_number: int | None,
        delivery_source: str,
        proxy_url: str,
    ) -> None:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                INSERT INTO proxy_delivery_logs (
                    proxy_link_id,
                    user_id,
                    tg_user_id,
                    user_label,
                    subscription_id,
                    device_number,
                    delivery_source,
                    proxy_url,
                    delivered_at
                )
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                """,
                (
                    proxy_link_id,
                    user_id,
                    tg_user_id,
                    user_label,
                    subscription_id,
                    device_number,
                    delivery_source,
                    proxy_url,
                    now_ts(),
                ),
            )
        await self.conn.commit()

    async def add_temp_message(
        self,
        *,
        user_id: int,
        tg_user_id: int,
        message_id: int,
        kind: str,
    ) -> None:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                INSERT INTO user_temp_messages (user_id, tg_user_id, message_id, kind, created_at)
                VALUES (%s, %s, %s, %s, %s)
                ON CONFLICT (user_id, message_id, kind) DO NOTHING
                """,
                (user_id, tg_user_id, message_id, kind, now_ts()),
            )
        await self.conn.commit()

    async def pop_temp_messages(self, *, user_id: int, kind: str) -> list[dict[str, Any]]:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                SELECT id, tg_user_id, message_id
                FROM user_temp_messages
                WHERE user_id = %s AND kind = %s
                ORDER BY id ASC
                """,
                (user_id, kind),
            )
            rows = await cur.fetchall()
            if rows:
                await cur.execute(
                    """
                    DELETE FROM user_temp_messages
                    WHERE user_id = %s AND kind = %s
                    """,
                    (user_id, kind),
                )
        await self.conn.commit()
        return [dict(row) for row in rows]

    async def get_user_ban(self, tg_user_id: int) -> dict[str, Any] | None:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                SELECT tg_user_id, reason, blocked_by, blocked_at
                FROM banned_users
                WHERE tg_user_id = %s
                """,
                (tg_user_id,),
            )
            row = await cur.fetchone()
        return dict(row) if row is not None else None

    async def ban_user(self, tg_user_id: int, reason: str, blocked_by: int | None = None) -> None:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                INSERT INTO banned_users (tg_user_id, reason, blocked_by, blocked_at)
                VALUES (%s, %s, %s, %s)
                ON CONFLICT (tg_user_id) DO UPDATE SET
                    reason = EXCLUDED.reason,
                    blocked_by = EXCLUDED.blocked_by,
                    blocked_at = EXCLUDED.blocked_at
                """,
                (tg_user_id, reason, blocked_by, now_ts()),
            )
        await self.conn.commit()

    async def unban_user(self, tg_user_id: int) -> bool:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                DELETE FROM banned_users
                WHERE tg_user_id = %s
                """,
                (tg_user_id,),
            )
            changed = cur.rowcount > 0
        await self.conn.commit()
        return changed

    async def get_all_links_for_user(self, user_id: int) -> list[dict[str, Any]]:
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                SELECT
                    pl.id,
                    pl.subscription_id,
                    pl.device_number,
                    pl.link,
                    pl.status,
                    pl.created_at,
                    pl.expires_at,
                    p.title AS plan_title
                FROM proxy_links pl
                LEFT JOIN subscriptions s ON s.id = pl.subscription_id
                LEFT JOIN plans p ON p.code = s.plan_code
                WHERE pl.user_id = %s
                ORDER BY pl.created_at DESC, pl.id DESC
                """,
                (user_id,),
            )
            rows = await cur.fetchall()
        return [dict(row) for row in rows]

    async def get_active_links_for_user(self, user_id: int) -> list[dict[str, Any]]:
        timestamp = now_ts()
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                SELECT
                    pl.id,
                    pl.subscription_id,
                    pl.device_number,
                    pl.link,
                    pl.expires_at,
                    p.title AS plan_title
                FROM proxy_links pl
                JOIN subscriptions s ON s.id = pl.subscription_id
                JOIN plans p ON p.code = s.plan_code
                WHERE
                    pl.user_id = %s
                    AND pl.status = 'active'
                    AND pl.expires_at > %s
                    AND s.status = 'active'
                ORDER BY pl.expires_at ASC, pl.subscription_id ASC, pl.device_number ASC
                """,
                (user_id, timestamp),
            )
            rows = await cur.fetchall()
        return [dict(row) for row in rows]

    async def get_active_subscriptions_for_user(self, user_id: int) -> list[dict[str, Any]]:
        timestamp = now_ts()
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                SELECT
                    s.id,
                    s.plan_code,
                    s.expires_at,
                    p.title AS plan_title,
                    p.price_rub,
                    p.devices_count
                FROM subscriptions s
                JOIN plans p ON p.code = s.plan_code
                WHERE s.user_id = %s AND s.status = 'active' AND s.expires_at > %s
                ORDER BY s.expires_at ASC
                """,
                (user_id, timestamp),
            )
            rows = await cur.fetchall()
        return [dict(row) for row in rows]

    async def revoke_proxy_link_for_user(self, user_id: int, proxy_link_id: int) -> bool:
        timestamp = now_ts()
        await self.conn.execute("BEGIN")
        try:
            async with self.conn.cursor() as cur:
                await cur.execute(
                    """
                    SELECT id, subscription_id
                    FROM proxy_links
                    WHERE id = %s AND user_id = %s AND status = 'active'
                    """,
                    (proxy_link_id, user_id),
                )
                row = await cur.fetchone()
                if row is None:
                    await self.conn.rollback()
                    return False

                subscription_id = int(row["subscription_id"])

                await cur.execute(
                    """
                    UPDATE proxy_links
                    SET status = 'expired', expires_at = %s
                    WHERE id = %s
                    """,
                    (timestamp, proxy_link_id),
                )
                await cur.execute(
                    """
                    UPDATE proxy_pool
                    SET status = 'free', assigned_link_id = NULL, updated_at = %s
                    WHERE assigned_link_id = %s
                    """,
                    (timestamp, proxy_link_id),
                )
                await cur.execute(
                    """
                    UPDATE subscriptions
                    SET status = 'expired'
                    WHERE id = %s AND status = 'active' AND NOT EXISTS (
                        SELECT 1
                        FROM proxy_links
                        WHERE subscription_id = %s AND status = 'active' AND expires_at > %s
                    )
                    """,
                    (subscription_id, subscription_id, timestamp),
                )
            await self.conn.commit()
            return True
        except Exception:
            await self.conn.rollback()
            raise

    async def revoke_all_active_links_for_user(self, user_id: int) -> int:
        timestamp = now_ts()
        await self.conn.execute("BEGIN")
        try:
            async with self.conn.cursor() as cur:
                await cur.execute(
                    """
                    SELECT id
                    FROM proxy_links
                    WHERE user_id = %s AND status = 'active' AND expires_at > %s
                    """,
                    (user_id, timestamp),
                )
                rows = await cur.fetchall()
                if not rows:
                    await self.conn.rollback()
                    return 0

                link_ids = [int(row["id"]) for row in rows]

                await cur.execute(
                    """
                    UPDATE proxy_links
                    SET status = 'expired', expires_at = %s
                    WHERE id = ANY(%s)
                    """,
                    (timestamp, link_ids),
                )
                await cur.execute(
                    """
                    UPDATE proxy_pool
                    SET status = 'free', assigned_link_id = NULL, updated_at = %s
                    WHERE assigned_link_id = ANY(%s)
                    """,
                    (timestamp, link_ids),
                )
                await cur.execute(
                    """
                    UPDATE subscriptions
                    SET status = 'expired'
                    WHERE user_id = %s AND status = 'active' AND NOT EXISTS (
                        SELECT 1
                        FROM proxy_links
                        WHERE subscription_id = subscriptions.id AND status = 'active' AND expires_at > %s
                    )
                    """,
                    (user_id, timestamp),
                )
            await self.conn.commit()
            return len(link_ids)
        except Exception:
            await self.conn.rollback()
            raise

    async def expire_due_and_get_notified_users(self) -> list[int]:
        timestamp = now_ts()
        async with self.conn.cursor() as cur:
            await cur.execute(
                """
                UPDATE subscriptions
                SET status = 'expired'
                WHERE status = 'active' AND expires_at <= %s
                """,
                (timestamp,),
            )
            await cur.execute(
                """
                UPDATE proxy_links
                SET status = 'expired'
                WHERE status = 'active' AND expires_at <= %s
                """,
                (timestamp,),
            )
            await cur.execute(
                """
                UPDATE proxy_pool
                SET status = 'free', assigned_link_id = NULL, updated_at = %s
                WHERE assigned_link_id IN (
                    SELECT id FROM proxy_links WHERE status = 'expired'
                )
                """,
                (timestamp,),
            )

            await cur.execute(
                """
                SELECT DISTINCT u.tg_user_id
                FROM subscriptions s
                JOIN users u ON u.id = s.user_id
                WHERE s.status = 'expired' AND s.notified_expired = 0
                """
            )
            rows = await cur.fetchall()

            await cur.execute(
                """
                UPDATE subscriptions
                SET notified_expired = 1
                WHERE status = 'expired' AND notified_expired = 0
                """
            )
        await self.conn.commit()
        return [int(row["tg_user_id"]) for row in rows]
